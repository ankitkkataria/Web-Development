const bcrypt = require("bcrypt");

const hashPassword = async (passwordPlainText) => {
  // This function uses bcrypt library function to generate a hash for the password you pass in while also including a random salt in the process to generate a hash that also saves us from these reverse hash tables that people might have set up.
  const salt = await bcrypt.genSalt(12); // This arg here denotes the number of salt rounds with "salt round" they actually mean the cost factor. The cost factor controls how much time is needed to calculate a single BCrypt hash. The higher the cost factor, the more hashing rounds are done. Increasing the cost factor by 1 doubles the necessary time. The more time is necessary, the more difficult is brute-forcing. So, basically it makes our algorithm that computes hash purposefully slower so we can be safe from attackers everytime you run this gen salt function is will produce a different output even for the same input cause otherwise it won't save us from attackers anyways if they can find for every password ankit the exact salt value then they will make a reverse table for that too so we only use it to generate salt once later we use this salt only to again get the hashed password.
  const hashedPassword = await bcrypt.hash(passwordPlainText, salt); // This will return the hash pattern that we will store in our database.
  console.log(salt); // $2b$12$JqRQTJAlVkjuOWuifK7tU. (For ankit only once you'll get this if you call this function again on line 9 you'll get a differnt salt), Here 2b means Bcrypt algorithm and $12 means there are 12 salt rounds meaning and that's how long it should run so it can get the same hash if it ran with ankit with either the salt added to ankit's prefix or postfix according to the bcrypt algo.
  console.log(hashedPassword); // $2b$12$JqRQTJAlVkjuOWuifK7tU.PYgqVeUcZ3cLJufvAcZSVaLELvuMbE6 (For ankit) the reason this helps us in securing the password is they might have a bcrypt hash for ankit but they won't have a bcrypt hash for ankit$2b$12$JqRQTJAlVkjuOWuifK7tU in their table.
};

// hashPassword('ankit'); // To get the initial hash for your password.

const login = async (passwordEntered, hashedPassword) => {
  const result = await bcrypt.compare(passwordEntered, hashedPassword);
  if (result) {
    console.log("Logged you in! Successful match!");
  } else {
    console.log("Incorrect Password");
  }
};

// Now what we will do is when a user enters their username and password at the time or the registration we will store the user's username & hashedPassword in our database (Do note that this hashedPassword is generated by the function above called hashPassword so salt and everything will be included in the hashing process).
// Then when user tries to signin later we will go to that username and fetch the hashed password and use the password the user just entered and the hashed password you just fetched to see if this password with the salt that's included in the hashedPassword will generate the same hashed password.

// Calling login with right password with the hashedPassword copied from line no. 7.
// login("ankit", "$2b$12$JqRQTJAlVkjuOWuifK7tU.PYgqVeUcZ3cLJufvAcZSVaLELvuMbE6");

// Calling login with wrong password with the same hashedPassword.
login("nitesh", "$2b$12$JqRQTJAlVkjuOWuifK7tU.PYgqVeUcZ3cLJufvAcZSVaLELvuMbE6");
// Now you can uncomment the correct password one.

/*
Bcrypt does not have a database it stores the salt...
The salt is added to the hash in base64 format....
The question is how does bcrypt verifies the password when it has no database...?
What bcrypt does is that it extract the salt from the password hash... Use the salt extracted to encrypt the plain password and compares the new hash with the old hash to see if they are the same...
*/

// Question about password Salts ?
// If the password Salt is not a secret, what is stopping a hacker from getting the Salts and then using that with a list of common passwords to break into someone's account? If they have the salt and the password, what else does a hacker need to do to get access?

/* Ans :- Adding salt will make the job harder for a hacker, and they won't be able to use any precalculated tables if every salt is unique. Also, the salt is stored in the backend database, so unless they gain access to it, they won't know the salt either (if they just try to break/guess the password from the frontend, for example).
          I would recommend researching how salt adds to the security of hashed passwords online to read more, for example:
          https://security.stackexchange.com/questions/91141/how-secure-is-it-to-keep-the-salt-with-the-password-hash
          https://security.stackexchange.com/questions/17421/how-to-store-salt
          https://www.quora.com/Why-doesnt-salt-need-to-be-kept-secret-or-encrypted-in-the-database-before-being-hashed-with-a-password-Can-t-a-hacker-just-hash-the-stolen-salt-with-a-dictionary-list-of-passwords-and-match-the-result-with-the
          https://stackoverflow.com/questions/1098452/are-salts-useless-for-security-if-the-attacker-knows-them
          If the hacker cracks the password, that's what they need to gain access, since the correct password would be calculated to a correct hash by the server if they use the correct salt value in the process.
*/

// Short Ans :- Hashing the password with a salt makes it much harder for an attacker to use a precomputed list of hashes (aka rainbow tables) to run the discovered hash against. It will force him to compute the hashes again for any salted password hash he wants to crack.

// Note :-
// Salt doesn't have to be secret. However, it MUST be unique for each password. Consider this : if all your passwords are hashed with the same salt, then an attacker who gets access to your database "only" has to compute H(pwd+salt) for each possible pwd value and he gets all your passwords. If the salt is unique however, the same operation will only get him ONE password, the one associated with the salt he just tried.

// Other way of generating hashsed password without generating the salt separtely is through using the same method but instead of passing the second argument as salt we will just go ahead and pass the number of rounds that you want the salt generation to go through and that way that salt doesn't need to be generated separately and it all happens inside.

const hashPassword2 = async (passwordPlainText) => {
  const hashedPassword2 = await bcrypt.hash(passwordPlainText, 12);
  console.log(hashedPassword2);
};

hashPassword2("ankit");
